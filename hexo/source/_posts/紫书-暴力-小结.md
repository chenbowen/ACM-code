---
title: 紫书-暴力-小结
date: 2016-10-21 16:49:02
tags: 
categories:
- apoc
- 07-暴力求解法
- 小结
---
# 简单枚举
1. **[UVa 725 Division[1]](/2016/10/21/uva725/)**
2. **[UVa 10976 Fractions Again?![1]](/2016/10/21/uva10976/)**

# 枚举排列
1. **生成1~n的排列**
  - 利用递归和一个判重数组
2. **生成可重集的排列**
  - 沿用递归全排列的结构，每次从集合中选前面挑剩下的，且同一位置，一种元素只能出现一次。
3. **解答树**
  - 如果某问题的解可以由多个步骤得到，而每个步骤都有若干种选择，且可以用递归枚举实现，则它的工作方式可以用解答树来描述。
4. **next_permutation**
  - `next_permutation(p, p+n)`
  - 注意：根据字典序计算的，会修改p的值。同样适用于可重集。

# 枚举子集
1. **增量构造法**
  - 一次选出一个元素放到集合中，类似生成全排列，通过遍历有序集合，避免重复。
2. **二进制枚举**
  - A&B、A|B和A^B对应集合的交、并和对称差。
  - 空集为0，全集`ALL_BITS=(1<<n)-1`。
  - 补集为`ALL_BITS^A`

# 回溯法
应用范围很广，只要问题可以分成不太多的步骤，每个步骤又只有不太多的选择，都可以考虑应用回溯法。
1. **八皇后**
2. **[UVa 524 Prime Ring Problem[2]](/2016/10/22/uva524/)**
3. **[UVa 129 困难的串[2]](/2016/10/22/uva129/)**
4. **[UVa 140 带宽[2]](/2016/10/22/uva140/)**
	- 在求最优解的问题中，应尽量考虑最优性剪枝。往往需要记录下当前最优解，并想办法“预测”：计算最理想情况下的解，如果这样都比当前最优解差，则剪枝。
5. **[UVa 1354 天平难题[*]](/2016/10/23/uva1354/)**

# 路径寻找问题
路径寻找问题可以归结为隐式图的遍历，它的任务是找到一条从初始状态到终止状态的最优路径，而不是像回溯法那样找到一个符合某些要求的解。
1. **八数码**
	- 无权图的最短路用BFS求解。
	- 用hash技术实现结点判重：
		```cpp
		const int hashsize = 1000003;
		int head[hashsize], next[hashsize];
		void init_lookup_table() {MEM(head, 0);}
		int hash(State& s) {
			// 将状态转成整数
			// ...
			return v%hashsize;
		}
		bool try_to_insert(int s) {
			int h = hash(st[s]);
			int u = head[h];
			while (u) {
				// 判重
				if (memcmp(st[u], st[s], sizeof(st[u])) == 0)
					return false;
				u = next[u];
			}
			return true;
		}```
	- `set<int>` 也可以用来判重，但是效率低下，可以用来作“跳板”。
2. **[UVa 10603 倒水问题[1]](/2016/10/24/uva10403/)**
3. **[UVa 1601 The Morning after Halloween[4]](/2016/10/24/uva1601/)**

# 迭代加深搜索
迭代加深搜索是一个应用范围很广的算法，不仅可以像回溯法那样找一个解，也可以像状态空间搜索那样找一条路径。

1. **埃及分数问题**
	- 
