---
title: 并查集
tags:
- dsu
categories:
- 挑战编程竞赛
- 2.4基础数据结构
- 并查集
- 小结
date: 2016-10-30 11:43:32
---
# 并查集（disjoint set union）
一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。常常在使用中以森林来表示。

# 主要操作有：
## 初始化
把每个点所在集合初始化为其自身。
```cpp
int init() {
	for(int i = 1; i <= n; i++) {
		par[i] = i;
		rank[i] = 0;
	}
}
```
## 查找
查找元素所在的集合，即根节点。
```cpp
int find(int x) {
	if(par[x] == x) return x;
	return par[x] = find(par[x]);
}
```
**路径压缩**：如果路径较长，则修改信息，直接指向当前的根，以便下次查找的时候速度更快。

## 合并
将两个元素所在的集合合并为一个集合。
通常来说，合并之前，应先判断两个元素是否属于同一集合，这可用上面的“查找”操作实现。
```cpp
void union(int a, int b) {
	a = find(a);
	b = find(b);
	if(a != b) par[b] = a;
}
```
另有**按秩合并**的优化策略：“秩”为树的高度，每次合并时，总是将深度较小的树合并进深度较大的树。因为直接的合并最坏的情况下的时间复杂度是线性的。表示子集的树可能会倾斜，像一个链表。下面是一个例子最坏情况的场景。
```cpp
假设有4个元素 0, 1, 2, 3
初始化
0 1 2 3 

Do Union(0, 1)
   1   2   3  
  /
 0

Do Union(1, 2)
     2   3   
    /
   1
 /
0

Do Union(2, 3)
         3    
        /
      2
     /
   1
 /
0
```
**按秩合并**可以防止树的退化，最坏情况不会出现。
```cpp
void union(int a, int b) {
	int f1 = find(a), f2 = find(b);
	if(rank[f1] <= rank[f2]) {
		par[f1] = f2;
		if(rank[f1] == rank[f2])
			rank[f2]++;
	}
	else par[f2] = f1;
}
```
可以证明，同时使用路径压缩和按秩合并，单次操作的平摊复杂度为**$O(\alpha(n))$**，其中$\alpha$函数是Ackerman函数的反函数，这个函数增长很慢，在平常的应用中不超过**4**。由此可见，同时使用路径压缩和按秩合并的并查集效率非常高。


## 判断x和y是否属于同一个集合
```cpp
bool same(int x, int y) {
	return find(x) == find(y);
}
```
---

# 例题
[POJ 1182 食物链[4]](/2016/10/30/poj1182/)




