---
title: 贪心算法原理和霍夫曼编码问题
tags:
- greedy
categories:
- 挑战编程竞赛
- 2.2贪心
- 小结
date: 2016-10-29 15:36:10
---

# 算法导论中对贪心算法的描述

求解最优化问题的算法通常需要经过一系列的步骤，在每个步骤都面临多种选择。对于许多最优化问题，使用动态规划来求最优解有些杀鸡用牛刀了，可以使用更简单、更高效的算法。**贪心算法**就是这样的算法，它在每一步都做出当时看起来最佳的最优解，寄希望这样的选择能导致全局最优解。
贪心算法并不保证得到最优解，但对很多问题确实可以求得最优解。

---

不难看出贪心算法是**动态规划算法在特殊情况下的简化版本**，贪心可以解决的问题是动规的子集。而在问题的数据范围很大时，只能用贪心而不是动规解决。


# 贪心算法原理

## 设计贪心算法的一般步骤：
1. 将最优化问题转化为这样的形式：对其作出一次选择后，只剩下**一个子问题**需要求解。
2. 证明做出**贪心选择**后，原问题总是存在最优解，即贪心选择总是安全的。
3. 证明做出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了**最优子结构**。

---

贪心算法可以求解的最优化问题通常满足**贪心选择性质**和**最优子结构**

## 贪心选择性质
我们可以通过做出局部最优选择来构造全局最优解。我们通常自底向上的方式求解动态规划问题，而一个贪心算法通常是自顶向下，进行一次又一次选择，将给定的问题实例变得更小。
如何证明贪心选择可以生成全局最优解？通常首先考察某个子问题的最优解，然后用贪心选择**替换**某个其他选择，修改此解。再试证明得到了一个**不比最优解差**的新解。

## 最优子结构
如果一个问题的最优解包含其子问题的最优解，则称此问题具有**最优子结构**性质。此性质是能否应用动态规划和贪心方法的关键要素。


# 霍夫曼编码
也叫**最优编码问题**。给出 $n$ 个字符的频率 $C_{i}$，给每个字符赋予一个$01$编码串，使得任意一个字符的编码不是另一个字符编码的前缀，而且编码后总长度（每个字符的频率与编码长度乘积的总和）尽量小。

## 分析
首先，任何一个前缀编码都可以表示成每个非叶结点恰好有两个子结点的二叉树。每个非叶结点与左子节点的边上写1，与右子节点的边上写0。因此问题转化成，求一颗最优编码树，每个叶子节点是一个字符，使得每个字符的频率乘上它的深度总和最小。

### Huffman算法
把每个字符看成一个单结点子树放在一个树集合中，每颗子树的权值等于相应的字符的频率。每次取权值最小的两颗子树合并成一颗新树，并重新放到集合中。新树的权值等于两颗子树权值之和。

下面分两步证明算法的正确性。

#### 结论1：
设x和y是频率最小的两个字符，则存在前缀码使得x和y具有相同码长，且仅有最后一位编码不同。换句话说，第一步贪心算法保留最优解，也就是具有**贪心选择性质**。

**证明：**假设深度最大的结点为a，则a一定有一个兄弟b。不妨设$f(x)\leqslant f(y), f(a)\leqslant f(b),$则$f(x)\leqslant f(a), f(y)\leqslant f(b)$。如果x 不是a，则交换x和a；如果y不是b，则交换 $y$ 和 $b$。这样得到的新编码树不会比原来的差。

#### 结论2：
设T是加权字符集C的最优编码树，x和y是树T中两个叶子，且互为兄弟节点，z是他们的父节点。若把z看成具有频率$f(z)=f(x)+f(y)$的字符，则树$T'=T-${$x,y$}是字符集$C'=C-${$x,y$}$ \cup{z}$的一颗最优编码树。换句话说，问题具有**最优子结构性质**。

**证明：**设$T'$的编码长度为L，其中字符{x,y}的深度为h，则把字符{x,y}拆成两个后，长度变为$L-(f(x)+f(y))\cdot h+(f(x)+f(y))\cdot (h+1)=L+f(x)+f(y)$。因此$T'$必须是$C'$的最优编码树，T才是C的最优编码树。

## 例题
[POJ 3253](http://poj.org/problem?id=3253)

